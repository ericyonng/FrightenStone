
#include "windows.h"
#include "dbghelp.h"
#include <BaseCode/CrashDumper.h>
#include <BaseCode/enumtype.h>
#pragma comment(lib, "BaseCode\\lib\\Debug\\DbgHelp.Lib")


// ExceptionHandler.cpp  Version 1.4
//
// Copyright ?1998 Bruce Dawson
//
// This source file contains the exception handler for recording error
// information after crashes. See ExceptionHandler.h for information
// on how to hook it in.
//
// Author:       Bruce Dawson
//               brucedawson@cygnus-software.com
//
// Modified by:  Hans Dietrich
//               hdietrich2@hotmail.com
//
// Version 1.4:  - Added invocation of XCrashReport.exe
//
// Version 1.3:  - Added minidump output
//
// Version 1.1:  - reformatted output for XP-like error report
//               - added ascii output to stack dump
//
// A paper by the original author can be found at:
//     http://www.cygnus-software.com/papers/release_debugging.html
//
///////////////////////////////////////////////////////////////////////////////

// Disable warnings generated by the Windows header files.
#pragma warning(disable : 4514)
#pragma warning(disable : 4201)



// comment out this line if you don't want minidumps
#define XCRASHREPORT_WRITE_MINIDUMP


// does not require MFC;  use 'Not using precompiled headers'

#include <tchar.h>

#ifndef _countof
#define _countof(array) (sizeof(array)/sizeof(array[0]))
#endif

const int NumCodeBytes = 16;	// Number of code bytes to record.
const int MaxStackDump = 3072;	// Maximum number of DWORDS in stack dumps.
const int StackColumns = 4;		// Number of columns in stack dump.

#define	ONEK			1024
#define	SIXTYFOURK		(64*ONEK)
#define	ONEM			(ONEK*ONEK)
#define	ONEG			(ONEK*ONEK*ONEK)


								///////////////////////////////////////////////////////////////////////////////
								// lstrrchr (avoid the C Runtime )
// static TCHAR * lstrrchr(LPCTSTR string, int ch)
// {
// 	TCHAR *start = (TCHAR *)string;
// 
// 	while (*string++)                       /* find end of string */
// 		;
// 	/* search towards front */
// 	while (--string != start && *string != (TCHAR)ch)
// 		;
// 
// 	if (*string == (TCHAR)ch)                /* char found ? */
// 		return (TCHAR *)string;
// 
// 	return NULL;
// }

///////////////////////////////////////////////////////////////////////////////
// hprintf behaves similarly to printf, with a few vital differences.
// It uses wvsprintf to do the formatting, which is a system routine,
// thus avoiding C run time interactions. For similar reasons it
// uses WriteFile rather than fwrite.
// The one limitation that this imposes is that wvsprintf, and
// therefore hprintf, cannot handle floating point numbers.

// Too many calls to WriteFile can take a long time, causing
// confusing delays when programs crash. Therefore I implemented
// a simple buffering scheme for hprintf

// #define HPRINTF_BUFFER_SIZE (8*1024)				// must be at least 2048
// static TCHAR hprintf_buffer[HPRINTF_BUFFER_SIZE];	// wvsprintf never prints more than one K.
// static int  hprintf_index = 0;

///////////////////////////////////////////////////////////////////////////////
// hflush
// static void hflush(HANDLE LogFile)
// {
// 	if (hprintf_index > 0)
// 	{
// 		DWORD NumBytes;
// 		WriteFile(LogFile, hprintf_buffer, lstrlen(hprintf_buffer), &NumBytes, 0);
// 		hprintf_index = 0;
// 	}
// }

///////////////////////////////////////////////////////////////////////////////
// hprintf


#ifdef XCRASHREPORT_WRITE_MINIDUMP

///////////////////////////////////////////////////////////////////////////////
// DumpMiniDump
static void DumpMiniDump(HANDLE hFile, PEXCEPTION_POINTERS excpInfo)
{
	if (excpInfo == NULL)
	{
		// Generate exception to get proper context in dump
		CONTEXT SavedContextRec;
		EXCEPTION_RECORD SavedExceptionRec;
		EXCEPTION_POINTERS ExceptionInfo;
		ExceptionInfo.ContextRecord = &SavedContextRec;
		ExceptionInfo.ExceptionRecord = &SavedExceptionRec;
		__try
		{
			//OutputDebugString(_T("raising exception\r\n"));
			RaiseException(EXCEPTION_BREAKPOINT, 0, 0, NULL);
		}
		__except (ASSERT(gtool::SehLock()), SavedExceptionRec = *(GET_EXCEPTION_INFO()->ExceptionRecord), SavedContextRec = *(GET_EXCEPTION_INFO()->ContextRecord), ASSERT(gtool::SehUnlock()), DumpMiniDump(hFile, &ExceptionInfo),
			EXCEPTION_CONTINUE_EXECUTION)
		{
		}
	}
	else
	{
		MINIDUMP_EXCEPTION_INFORMATION eInfo;
		eInfo.ThreadId = GetCurrentThreadId();
		eInfo.ExceptionPointers = excpInfo;
		eInfo.ClientPointers = FALSE;

		// note:  MiniDumpWithIndirectlyReferencedMemory does not work on Win98
		MiniDumpWriteDump(
			GetCurrentProcess(),
			GetCurrentProcessId(),
			hFile,
			MiniDumpNormal,
			&eInfo,
			NULL,
			NULL);
	}
}

#endif	// XCRASHREPORT_WRITE_MINIDUMP

///////////////////////////////////////////////////////////////////////////////
// FormatTime
//
// Format the specified FILETIME to output in a human readable format,
// without using the C run time.


///////////////////////////////////////////////////////////////////////////////
// DumpModuleInfo
//
// Print information about a code module (DLL or EXE) such as its size,
// location, time stamp, etc.
static bool DumpModuleInfo(gtool::CFmtIOString &rBufferOut, HINSTANCE ModuleHandle, int nModuleNo)
{
	bool rc = false;
	char szModName[MAX_PATH * 2] = {0};

	__try
	{
		if (GetModuleFileName(ModuleHandle, szModName, sizeof(szModName) - 1) > 0)
		{
			// If GetModuleFileName returns greater than zero then this must
			// be a valid code module address. Therefore we can try to walk
			// our way through its structures to find the link time stamp.
			IMAGE_DOS_HEADER *DosHeader = (IMAGE_DOS_HEADER*)ModuleHandle;
			if (IMAGE_DOS_SIGNATURE != DosHeader->e_magic)
				return false;

			IMAGE_NT_HEADERS *NTHeader = (IMAGE_NT_HEADERS*)((char *)DosHeader
				+ DosHeader->e_lfanew);
			if (IMAGE_NT_SIGNATURE != NTHeader->Signature)
				return false;


			BUFFER1024 TimeBuffer = { 0 };
			sprintf(TimeBuffer, "Module %d\r\n", nModuleNo);
			rBufferOut << TimeBuffer;
			TimeBuffer[0] = 0;
			auto nLen = sprintf(TimeBuffer, "%s\r\n", szModName);
			nLen = ((nLen < sizeof(TimeBuffer)) ? gtool::Max(nLen, 0) : (sizeof(TimeBuffer) - 1));
			TimeBuffer[nLen] = 0;
			rBufferOut << TimeBuffer;
			TimeBuffer[0] = 0;
			nLen = sprintf(TimeBuffer, "Image Base: 0x%I64x  Image Size: 0x%lu\r\n"
				, NTHeader->OptionalHeader.ImageBase, NTHeader->OptionalHeader.SizeOfImage);
			nLen = ((nLen < sizeof(TimeBuffer)) ? gtool::Max(nLen, 0) : (sizeof(TimeBuffer) - 1));
			TimeBuffer[nLen] = 0;
			rBufferOut << TimeBuffer;
			TimeBuffer[0] = 0;
			nLen = sprintf(TimeBuffer, "Checksum:   0x%lu  Time Stamp: 0x%lu\r\n"
				, NTHeader->OptionalHeader.CheckSum
				, NTHeader->FileHeader.TimeDateStamp);
			nLen = ((nLen < sizeof(TimeBuffer)) ? gtool::Max(nLen, 0) : (sizeof(TimeBuffer) - 1));
			TimeBuffer[nLen] = 0;
			rBufferOut << TimeBuffer;

			rc = true;
		}
	}
	// Handle any exceptions by continuing from this point.
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
	}
	return rc;
}

///////////////////////////////////////////////////////////////////////////////
// DumpModuleList
//
// Scan memory looking for code modules (DLLs or EXEs). VirtualQuery is used
// to find all the blocks of address space that were reserved or committed,
// and ShowModuleInfo will display module information if they are code
// modules.
static void DumpModuleList(gtool::CFmtIOString &rBufferOut)
{
	SYSTEM_INFO	SystemInfo;
	GetSystemInfo(&SystemInfo);

	const size_t PageSize = SystemInfo.dwPageSize;

	// Set NumPages to the number of pages in the 4GByte address space,
	// while being careful to avoid overflowing ints
	const size_t NumPages = 4 * size_t(ONEG / PageSize);
	size_t pageNum = 0;
	void *LastAllocationBase = 0;

	int nModuleNo = 1;

	while (pageNum < NumPages)
	{
		MEMORY_BASIC_INFORMATION MemInfo;
		if (VirtualQuery((void *)(pageNum * PageSize), &MemInfo,
			sizeof(MemInfo)))
		{
			if (MemInfo.RegionSize > 0)
			{
				// Adjust the page number to skip over this block of memory
				pageNum += MemInfo.RegionSize / PageSize;
				if (MemInfo.State == MEM_COMMIT && MemInfo.AllocationBase >
					LastAllocationBase)
				{
					// Look for new blocks of committed memory, and try
					// recording their module names - this will fail
					// gracefully if they aren't code modules
					LastAllocationBase = MemInfo.AllocationBase;
					if (DumpModuleInfo(rBufferOut,
						(HINSTANCE)LastAllocationBase,
						nModuleNo))
					{
						nModuleNo++;
					}
				}
			}
			else
				pageNum += SIXTYFOURK / PageSize;
		}
		else
			pageNum += SIXTYFOURK / PageSize;

		// If VirtualQuery fails we advance by 64K because that is the
		// granularity of address space doled out by VirtualAlloc()
	}
}

///////////////////////////////////////////////////////////////////////////////
// DumpSystemInformation
//
// Record information about the user's system, such as processor type, amount
// of memory, etc.
static void DumpSystemInformation(gtool::CFmtIOString &rBufferOut)
{
	time_t tCur = time(NULL);
	auto nCurYYYYMMDDHHMMSS = gtool::GetYYYYMMDDHHMMSS(tCur);
	rBufferOut << "Error occurred at time:" << nCurYYYYMMDDHHMMSS<< gtool::CFmtIOString::endl;

	char szModuleName[MAX_PATH * 2] = { 0 };
	if (GetModuleFileName(0, szModuleName, sizeof(szModuleName)-1) <= 0)
		strcpy(szModuleName, "Unknown");

// 	char szUserName[200] = { 0 };
// 	MYULONG UserNameSize = sizeof(szUserName) - 1;
// 	if (!GetUserName(szUserName, &UserNameSize))
// 		strcpy(szUserName, "Unknown");

	rBufferOut << szModuleName << gtool::CFmtIOString::endl;

	SYSTEM_INFO	SystemInfo;
	GetSystemInfo(&SystemInfo);
	rBufferOut<< SystemInfo.dwNumberOfProcessors<<" processor(s), type:"<< SystemInfo.dwProcessorType<< gtool::CFmtIOString::endl;

	MEMORYSTATUS MemInfo;
	MemInfo.dwLength = sizeof(MemInfo);
	GlobalMemoryStatus(&MemInfo);

	// Print out info on memory, rounded up.
	gtool::DumperBuffer<DUMPER_BUFFER_TYPE_SMALLER> rBuffer;
	rBuffer.Buffer[0] = 0;
	auto nLen = sprintf(rBuffer.Buffer, "%d%% memory in use.\r\n"\
							"%d MBytes physical memory.\r\n"	\
							"%d MBytes physical memory free.\r\n"	\
							"%d MBytes paging file.\r\n"		\
							"%d MBytes paging file free.\r\n"		\
							"%d MBytes user address space.\r\n"	\
							"%d MBytes user address space free\r\n"
		, MemInfo.dwMemoryLoad
		, I32((MemInfo.dwTotalPhys + ONEM - 1) / ONEM)
		, I32((MemInfo.dwAvailPhys + ONEM - 1) / ONEM)
		, I32((MemInfo.dwTotalPageFile + ONEM - 1) / ONEM)
		, I32((MemInfo.dwAvailPageFile + ONEM - 1) / ONEM)
		, I32((MemInfo.dwTotalVirtual + ONEM - 1) / ONEM)
		, I32((MemInfo.dwAvailVirtual + ONEM - 1) / ONEM)
	);
	nLen = ((nLen < sizeof(rBuffer.Buffer)) ? gtool::Max(nLen, 0) : (sizeof(rBuffer.Buffer) - 1));
	rBuffer.Buffer[nLen] = 0;

	rBufferOut << rBuffer.Buffer << gtool::CFmtIOString::endl;
}

///////////////////////////////////////////////////////////////////////////////
// GetExceptionDescription
//
// Translate the exception code into something human readable
static const char *GetExceptionDescription(MYULONG ExceptionCode)
{
	struct ExceptionNames
	{
		MYULONG	ExceptionCode;
		char *	ExceptionName;
	};

#if 0  // from winnt.h
#define STATUS_WAIT_0                    ((DWORD   )0x00000000L)    
#define STATUS_ABANDONED_WAIT_0          ((DWORD   )0x00000080L)    
#define STATUS_USER_APC                  ((DWORD   )0x000000C0L)    
#define STATUS_TIMEOUT                   ((DWORD   )0x00000102L)    
#define STATUS_PENDING                   ((DWORD   )0x00000103L)    
#define STATUS_SEGMENT_NOTIFICATION      ((DWORD   )0x40000005L)    
#define STATUS_GUARD_PAGE_VIOLATION      ((DWORD   )0x80000001L)    
#define STATUS_DATATYPE_MISALIGNMENT     ((DWORD   )0x80000002L)    
#define STATUS_BREAKPOINT                ((DWORD   )0x80000003L)    
#define STATUS_SINGLE_STEP               ((DWORD   )0x80000004L)    
#define STATUS_ACCESS_VIOLATION          ((DWORD   )0xC0000005L)    
#define STATUS_IN_PAGE_ERROR             ((DWORD   )0xC0000006L)    
#define STATUS_INVALID_HANDLE            ((DWORD   )0xC0000008L)    
#define STATUS_NO_MEMORY                 ((DWORD   )0xC0000017L)    
#define STATUS_ILLEGAL_INSTRUCTION       ((DWORD   )0xC000001DL)    
#define STATUS_NONCONTINUABLE_EXCEPTION  ((DWORD   )0xC0000025L)    
#define STATUS_INVALID_DISPOSITION       ((DWORD   )0xC0000026L)    
#define STATUS_ARRAY_BOUNDS_EXCEEDED     ((DWORD   )0xC000008CL)    
#define STATUS_FLOAT_DENORMAL_OPERAND    ((DWORD   )0xC000008DL)    
#define STATUS_FLOAT_DIVIDE_BY_ZERO      ((DWORD   )0xC000008EL)    
#define STATUS_FLOAT_INEXACT_RESULT      ((DWORD   )0xC000008FL)    
#define STATUS_FLOAT_INVALID_OPERATION   ((DWORD   )0xC0000090L)    
#define STATUS_FLOAT_OVERFLOW            ((DWORD   )0xC0000091L)    
#define STATUS_FLOAT_STACK_CHECK         ((DWORD   )0xC0000092L)    
#define STATUS_FLOAT_UNDERFLOW           ((DWORD   )0xC0000093L)    
#define STATUS_INTEGER_DIVIDE_BY_ZERO    ((DWORD   )0xC0000094L)    
#define STATUS_INTEGER_OVERFLOW          ((DWORD   )0xC0000095L)    
#define STATUS_PRIVILEGED_INSTRUCTION    ((DWORD   )0xC0000096L)    
#define STATUS_STACK_OVERFLOW            ((DWORD   )0xC00000FDL)    
#define STATUS_CONTROL_C_EXIT            ((DWORD   )0xC000013AL)    
#define STATUS_FLOAT_MULTIPLE_FAULTS     ((DWORD   )0xC00002B4L)    
#define STATUS_FLOAT_MULTIPLE_TRAPS      ((DWORD   )0xC00002B5L)    
#define STATUS_ILLEGAL_VLM_REFERENCE     ((DWORD   )0xC00002C0L)     
#endif

	ExceptionNames ExceptionMap[] =
	{
		{ 0x40010005, "a Control-C" },
		{ 0x40010008, "a Control-Break" },
		{ 0x80000002, "a Datatype Misalignment" },
		{ 0x80000003, "a Breakpoint" },
		{ 0xc0000005, "an Access Violation" },
		{ 0xc0000006, "an In Page Error" },
		{ 0xc0000017, "a No Memory" },
		{ 0xc000001d, "an Illegal Instruction" },
		{ 0xc0000025, "a Noncontinuable Exception" },
		{ 0xc0000026, "an Invalid Disposition" },
		{ 0xc000008c, "a Array Bounds Exceeded" },
		{ 0xc000008d, "a Float Denormal Operand" },
		{ 0xc000008e, "a Float Divide by Zero" },
		{ 0xc000008f, "a Float Inexact Result" },
		{ 0xc0000090, "a Float Invalid Operation" },
		{ 0xc0000091, "a Float Overflow" },
		{ 0xc0000092, "a Float Stack Check" },
		{ 0xc0000093, "a Float Underflow" },
		{ 0xc0000094, "an Integer Divide by Zero" },
		{ 0xc0000095, "an Integer Overflow" },
		{ 0xc0000096, "a Privileged Instruction" },
		{ 0xc00000fD, "a Stack Overflow" },
		{ 0xc0000142, "a DLL Initialization Failed" },
		{ 0xe06d7363, "a Microsoft C++ Exception" },
	};
	for (int i = 0; i < sizeof(ExceptionMap) / sizeof(ExceptionMap[0]); i++)
		if (ExceptionCode == ExceptionMap[i].ExceptionCode)
			return ExceptionMap[i].ExceptionName;

	return "an Unknown exception type";
}

///////////////////////////////////////////////////////////////////////////////
// GetFilePart
static char * GetFilePart(char* source)
{
	char *result = strrchr(source, '\\');
	if (result)
		result++;
	else
		result = (char *)source;
	return result;
}

///////////////////////////////////////////////////////////////////////////////
// DumpStack
static void DumpStack(gtool::CFmtIOString &rBufferOut, MYULONG *pStack)
{
	UNUSED_ARG(pStack);
	UNUSED_ARG(rBufferOut);
// 	rBufferOut << "\r\n\r\nStack:\r\n";
// 
// 	__try
// 	{
// 		// Esp contains the bottom of the stack, or at least the bottom of
// 		// the currently used area.
// 		MYULONG* pStackTop;
// 
// 		__asm
// 		{
// 			// Load the top (highest address) of the stack from the
// 			// thread information block. It will be found there in
// 			// Win9x and Windows NT.
// 			mov	eax, fs:[4]
// 			mov pStackTop, eax
// 		}
// 
// 		if (pStackTop > pStack + MaxStackDump)
// 			pStackTop = pStack + MaxStackDump;
// 
// 		int Count = 0;
// 
// 		MYULONG* pStackStart = pStack;
// 
// 		int nDwordsPrinted = 0;
// 
// 		DumperBuffer<DUMPER_BUFFER_TYPE_SMALLER> rBuffer;
// 		I32 nLen = 0;
// 		while (pStack + 1 <= pStackTop)
// 		{
// 			if ((Count % StackColumns) == 0)
// 			{
// 				pStackStart = pStack;
// 				nDwordsPrinted = 0;
// 				rBuffer.Buffer[0] = 0;
// 				nLen = sprintf(rBuffer.Buffer, "0x%08x: ", pStack);
// 				rBuffer.Buffer[nLen] = 0;
// 				rBufferOut << rBuffer.Buffer;
// 			}
// 
// 			if ((++Count % StackColumns) == 0 || pStack + 2 > pStackTop)
// 			{
// 				rBuffer.Buffer[0] = 0;
// 				nLen = sprintf(rBuffer.Buffer, "%08x ", *pStack);
// 				rBuffer.Buffer[nLen] = 0;
// 				rBufferOut << rBuffer.Buffer;
// 				nDwordsPrinted++;
// 
// 				int n = nDwordsPrinted;
// 				while (n < 4)
// 				{
// 					rBufferOut << "         ";
// 					n++;
// 				}
// 
// 				for (int i = 0; i < nDwordsPrinted; i++)
// 				{
// 					DWORD dwStack = *pStackStart;
// 					for (int j = 0; j < 4; j++)
// 					{
// 						char c = (char)(dwStack & 0xFF);
// 						if (c < 0x20 || c > 0x7E)
// 							c = '.';
// 
// 						rBuffer.Buffer[0] = 0;
// 						nLen = sprintf(rBuffer.Buffer, "%c ", c);
// 						rBuffer.Buffer[nLen] = 0;
// 						rBufferOut << rBuffer.Buffer;
// 						dwStack = dwStack >> 8;
// 					}
// 					pStackStart++;
// 				}
// 
// 				rBufferOut << CFmtIOString::endl;
// 			}
// 			else
// 			{
// 				rBuffer.Buffer[0] = 0;
// 				nLen = sprintf(rBuffer.Buffer, "%08x ", *pStack);
// 				rBuffer.Buffer[nLen] = 0;
// 				rBufferOut << rBuffer.Buffer;
// 				nDwordsPrinted++;
// 			}
// 			pStack++;
// 		}
// 		rBufferOut << CFmtIOString::endl;
// 	}
// 	__except (EXCEPTION_EXECUTE_HANDLER)
// 	{
// 		rBufferOut<<"Exception encountered during stack dump."<< CFmtIOString::endl;
// 	}
}

///////////////////////////////////////////////////////////////////////////////
// DumpRegisters
static void DumpRegisters(gtool::CFmtIOString &rBufferOut, PCONTEXT Context)
{
	// Print out the register values in an XP error window compatible format.
	rBufferOut << "\r\n" << "Context:\r\n" << "";
	gtool::DumperBuffer<DUMPER_BUFFER_TYPE_SMALLER> rBuffer;
	rBuffer.Buffer[0] = 0;
	auto nLen = sprintf(rBuffer.Buffer, "RDI:    0x%I64x  RSI: 0x%I64x  RAX:   0x%I64x\r\n", Context->Rdi, Context->Rsi, Context->Rax);
	nLen = ((nLen < sizeof(rBuffer.Buffer)) ? gtool::Max(nLen, 0) : (sizeof(rBuffer.Buffer) - 1));
	rBuffer.Buffer[nLen] = 0;
	rBufferOut << rBuffer.Buffer;
	rBuffer.Buffer[0] = 0;
	nLen = sprintf(rBuffer.Buffer, "RBX:    0x%I64x  RCX: 0x%I64x  RDX:   0x%I64x\r\n", Context->Rbx, Context->Rcx, Context->Rdx);
	nLen = ((nLen < sizeof(rBuffer.Buffer)) ? gtool::Max(nLen, 0) : (sizeof(rBuffer.Buffer) - 1));
	rBuffer.Buffer[nLen] = 0;
	rBufferOut << rBuffer.Buffer;
	rBuffer.Buffer[0] = 0;
	nLen = sprintf(rBuffer.Buffer, "RIP:    0x%I64x  RBP: 0x%I64x  SegCs: 0x%I64x\r\n", Context->Rip, Context->Rbp, U64(Context->SegCs));
	nLen = ((nLen < sizeof(rBuffer.Buffer)) ? gtool::Max(nLen, 0) : (sizeof(rBuffer.Buffer) - 1));
	rBuffer.Buffer[nLen] = 0;
	rBufferOut << rBuffer.Buffer;
	rBuffer.Buffer[0] = 0;
	nLen = sprintf(rBuffer.Buffer, "EFlags: 0x%I64x  RSP: 0x%I64x  SegSs: 0x%I64x\r\n", U64(Context->EFlags), Context->Rsp, U64(Context->SegSs));
	nLen = ((nLen < sizeof(rBuffer.Buffer)) ? gtool::Max(nLen, 0) : (sizeof(rBuffer.Buffer) - 1));
	rBuffer.Buffer[nLen] = 0;
	rBufferOut << rBuffer.Buffer;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// RecordExceptionInfo
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// LONG WINAPI MyFilter(PEXCEPTION_POINTERS pExceptionInfo)
// {
// 	EXCEPTION_RECORD ExceptionRec;
// 	CONTEXT ContextRec;
// 	ExceptionRec = *pExceptionInfo->ExceptionRecord;
// 	ContextRec = *pExceptionInfo->ContextRecord;
// 
// #ifndef _DEBUG
// 
// 	if (IsDebuggerPresent())
// 	{
// 		// let the debugger catch this -
// 		// return the magic value which tells Win32 that this handler didn't
// 		// actually handle the exception - so that things will proceed as per
// 		// normal.
// 		return EXCEPTION_CONTINUE_SEARCH;
// 	}
// 
// #endif // !_DEBUG
// 
// 	return EXCEPTION_EXECUTE_HANDLER;
// }



typedef gtool::CSingleton<CDataLocker> SehLockerInstance;
#define SehLocker2	(*SehLockerInstance::GetInstance())


NAMESPACE_BEGIN(gtool)

bool SehLock()
{
	return SehLocker2.Lock();
}

bool SehUnlock()
{
	return SehLocker2.UnLock();
}

// bool RegisterExceptionFilter()
// {
// 	SetUnhandledExceptionFilter(MyFilter);
// 	return true;
// }

I32  RecordExceptionInfo(EXCEPTION_RECORD ExceptionRec, CONTEXT ContextRec, const char *Message, CFmtIOString &rBufferOut, bool bSimpleInfo)
{
	//组合异常结构体指针
	EXCEPTION_POINTERS ExceptStruct;
	ExceptStruct.ContextRecord = &ContextRec;
	ExceptStruct.ExceptionRecord = &ExceptionRec;
	PEXCEPTION_POINTERS pExceptPtrs = &ExceptStruct;

	DumperBuffer<DUMPER_BUFFER_TYPE_SMALLER> rBuffer, DumpFile;
	char szRandName[L_tmpnam] = { 0 };
	gtool::CFileDirSys::GenRandFileNameNoDir(szRandName);

	//写入dump文件
	DumpFile.Buffer[0] = 0;
	SYSTEMTIME tm_now = { 0 };
	GetLocalTime(&tm_now);
	auto nFileNameLen = sprintf(DumpFile.Buffer, "%s%s%hu-%hu-%hu %02hu%02hu%02hu-%03hu.dmp", "CrashDump"
		, szRandName, tm_now.wYear, tm_now.wMonth, tm_now.wDay, tm_now.wHour, tm_now.wMinute, tm_now.wSecond, tm_now.wMilliseconds);
	nFileNameLen = ((nFileNameLen < sizeof(DumpFile.Buffer)) ? gtool::Max(nFileNameLen, 0) : (sizeof(DumpFile.Buffer) - 1));
	DumpFile.Buffer[nFileNameLen] = 0;

	// Create dump文件
	HANDLE hMiniDumpFile = CreateFile(
		DumpFile.Buffer,
		GENERIC_WRITE,
		0,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
		NULL);

	// Write the minidump to the file
	if (hMiniDumpFile != INVALID_HANDLE_VALUE)
	{
		//DumpMiniDump(hMiniDumpFile, pExceptPtrs);
		DumpMiniDump(hMiniDumpFile, pExceptPtrs);

		// Close file
		CloseHandle(hMiniDumpFile);
	}

	// Create a filename to record the error information to.
	// Storing it in the executable directory works well.
	rBufferOut << CFmtIOString::endl<< "◆◆◆◆◆◆◆◆◆◆		[CRASH DUMP INFO]！		◆◆◆◆◆◆◆◆◆◆" << CFmtIOString::endl;
	char szModuleName[MAX_PATH * 2] = {0};
	if (GetModuleFileName(0, szModuleName, sizeof(szModuleName)-1) <= 0)
		strcpy(szModuleName, "Unknown");

	char *pszFilePart = GetFilePart(szModuleName);

	// Extract the file name portion and remove it's file extension
	char szFileName[MAX_PATH * 2] = {0};
	strcpy(szFileName, pszFilePart);
	char *lastperiod = strrchr(szFileName, '.');
	if (lastperiod)
		lastperiod[0] = 0;

	// Replace the executable filename with our error log file name
	//lstrcpy(pszFilePart, XCRASHREPORT_ERROR_LOG_FILE);

	// Print out a blank line to separate this error log from any previous ones
	//hprintf(hLogFile, _T("\r\n"));

	PEXCEPTION_RECORD Exception = pExceptPtrs->ExceptionRecord;
	PCONTEXT          Context = pExceptPtrs->ContextRecord;	

	char szCrashModulePathName[MAX_PATH * 2] = { 0 };

	char *pszCrashModuleFileName = "Unknown";

	MEMORY_BASIC_INFORMATION MemInfo;

	// VirtualQuery can be used to get the allocation base associated with a
	// code address, which is the same as the ModuleHandle. This can be used
	// to get the filename of the module that the crash happened in.
	if (VirtualQuery((void*)Context->Rip, &MemInfo, sizeof(MemInfo)) &&
		(GetModuleFileName((HINSTANCE)MemInfo.AllocationBase,
			szCrashModulePathName,
			sizeof(szCrashModulePathName) -1) > 0))
	{
		pszCrashModuleFileName = GetFilePart(szCrashModulePathName);
	}

	// Print out the beginning of the error log in a Win95 error window
	// compatible format.
	
	rBuffer.Buffer[0] = 0;
	I32 nLen = sprintf(rBuffer.Buffer, "%s caused %s (0x%x) \r\nin module %s at 0x%x:0x%I64x.ExceptionAddress:0x%p NumberParameters:%lu("
		, szFileName
		, GetExceptionDescription(Exception->ExceptionCode)
		,Exception->ExceptionCode
		,pszCrashModuleFileName, Context->SegCs, Context->Rip, Exception->ExceptionAddress, Exception->NumberParameters);
	nLen = ((nLen < sizeof(rBuffer.Buffer)) ? gtool::Max(nLen, 0) : (sizeof(rBuffer.Buffer) - 1));
	rBuffer.Buffer[nLen] = 0;
	rBufferOut << rBuffer.Buffer;
	
	for (MYULONG i = 0; i < Exception->NumberParameters&&i<EXCEPTION_MAXIMUM_PARAMETERS; ++i)
	{
		rBuffer.Buffer[0] = 0;
		if (i == Exception->NumberParameters - 1 || i == EXCEPTION_MAXIMUM_PARAMETERS - 1)
		{
			nLen = sprintf(rBuffer.Buffer, "0x%I64x", Exception->ExceptionInformation[i]);
		}
		else
		{
			nLen = sprintf(rBuffer.Buffer, "0x%I64x,", Exception->ExceptionInformation[i]);
		}	
		nLen = ((nLen < sizeof(rBuffer.Buffer)) ? gtool::Max(nLen, 0) : (sizeof(rBuffer.Buffer) - 1));
		rBuffer.Buffer[nLen] = 0;
		rBufferOut << rBuffer.Buffer;
	}

	rBuffer.Buffer[0] = 0;
	nLen = sprintf(rBuffer.Buffer, ")\r\n\r\nException handler called in %s.\r\n", Message);
	nLen = ((nLen < sizeof(rBuffer.Buffer)) ? gtool::Max(nLen, 0) : (sizeof(rBuffer.Buffer) - 1));
	rBuffer.Buffer[nLen] = 0;
	rBufferOut << rBuffer.Buffer;	

	//dumpfile
	rBufferOut << "dumpfile:" << DumpFile.Buffer << CFmtIOString::endl;

	//系统信息
	DumpSystemInformation(rBufferOut);

	// If the exception was an access violation, print out some additional
	// information, to the error log and the debugger.
	if (Exception->ExceptionCode == STATUS_ACCESS_VIOLATION &&
		Exception->NumberParameters >= 2)
	{
		rBuffer.Buffer[0] = 0;
		char* readwrite = "Read from";
		if (Exception->ExceptionInformation[0])
			readwrite = "Write to";

		nLen = sprintf(rBuffer.Buffer, "%s location %I64x caused an access violation.\r\n",
			readwrite, Exception->ExceptionInformation[1]);
		nLen = ((nLen < sizeof(rBuffer.Buffer)) ? gtool::Max(nLen, 0) : (sizeof(rBuffer.Buffer) - 1));
		rBuffer.Buffer[nLen] = 0;
		rBufferOut << rBuffer.Buffer;
	}

	//寄存器信息
	DumpRegisters(rBufferOut, Context);

	// Print out the bytes of code at the instruction pointer. Since the
	// crash may have been caused by an instruction pointer that was bad,
	// this code needs to be wrapped in an exception handler, in case there
	// is no memory to read. If the dereferencing of code[] fails, the
	// exception handler will print '??'.

	rBuffer.Buffer[0] = 0;
	nLen = sprintf(rBuffer.Buffer, "\r\nBytes at CS:RIP:0x%x:0x%I64x.\r\n", Context->SegCs, Context->Rip);
	nLen = ((nLen < sizeof(rBuffer.Buffer)) ? gtool::Max(nLen, 0) : (sizeof(rBuffer.Buffer) - 1));
	rBuffer.Buffer[nLen] = 0;
	rBufferOut << rBuffer.Buffer;

	//ip指针指向的指令信息
	BYTE * code = (BYTE *)Context->Rip;
	for (int codebyte = 0; codebyte < NumCodeBytes; codebyte++)
	{
		__try
		{
			rBuffer.Buffer[0] = 0;
			nLen = sprintf(rBuffer.Buffer, "%02x ", code[codebyte]);
			nLen = ((nLen < sizeof(rBuffer.Buffer)) ? gtool::Max(nLen, 0) : (sizeof(rBuffer.Buffer) - 1));
			rBuffer.Buffer[nLen] = 0;
			rBufferOut << rBuffer.Buffer;

		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			rBufferOut << "?? ";
		}
	}
	rBufferOut << CFmtIOString::endl;

	// Time to print part or all of the stack to the error log. This allows
	// us to figure out the call stack, parameters, local variables, etc.

	// Esp contains the bottom of the stack, or at least the bottom of
	// the currently used area

	if (!bSimpleInfo)
	{
		DWORD* pStack = (DWORD *)Context->Rsp;

		//栈信息
		DumpStack(rBufferOut, pStack);

		//加载的模块信息
		DumpModuleList(rBufferOut);
	}

	///////////////////////////////////////////////////////////////////////////
	//
	// write minidump
	//
	///////////////////////////////////////////////////////////////////////////

//#ifdef XCRASHREPORT_WRITE_MINIDUMP

	// Replace the filename with our minidump file name

//#endif	// XCRASHREPORT_WRITE_MINIDUMP

	rBufferOut << CFmtIOString::endl << "◆◆◆◆◆◆◆◆◆◆		[CRASH DUMP END]！		◆◆◆◆◆◆◆◆◆◆" << CFmtIOString::endl;

#ifndef _DEBUG

	if (IsDebuggerPresent())
	{
		// let the debugger catch this -
		// return the magic value which tells Win32 that this handler didn't
		// actually handle the exception - so that things will proceed as per
		// normal.
		return EXCEPTION_CONTINUE_SEARCH;
	}

#endif // !_DEBUG

	return EXCEPTION_EXECUTE_HANDLER;
}


NAMESPACE_END(gtool)